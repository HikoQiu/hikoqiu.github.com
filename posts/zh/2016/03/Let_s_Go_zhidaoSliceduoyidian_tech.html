<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>[Let's Go] 关于Slice的一些事 - Hiko.im</title>
    <link rel="shortcut icon" href="../../../../resource/favicon.ico" type="image/x-icon" />
    <!--HiBlog-[Let's Go] 关于Slice的一些事`Hiko`2016-03-14 20:51:11`go,slice,array,value copy`tech`zh-HiBlog--><!-- meta data for index -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="../../../../resource/stylesheets/normalize.css" media="screen">
    <link rel='stylesheet' type='text/css' href='../../../../resource/stylesheets/google-css.css'>
    <link rel="stylesheet" type="text/css" href="../../../../resource/stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../../../../resource/stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-nav">
    <div class="page-nav-list">
        <a href='/index_zh.html'>首页</a><a href='/tech_zh.html'>编程</a><a href='/daily_zh.html'>随笔</a><a href='/posts/zh/2015/12/About_zh_daily.html'>关于</a>

        <a href="/index_en.html" style="float: right;">英文版</a>
        <a href="/index.html" style="float: right;">全部</a>
    </div>
</section>

    <section class="page-header">
        <h1 class="project-name">[Let's Go] 关于Slice的一些事</h1>
        <h2 class="project-tagline">by Hiko / go,slice,array,value copy</h2>
    </section>

    <section class="main-content">
        <div><h4>概览</h4>

<ul>
<li>1&#46; Slice数据结构</li>
<li>2&#46; 使用Slice须知</li>
<li>2.1 值传递下的Slice</li>
<li>2.2 Slice截取和扩充</li>
<li>3&#46; Slice操作常用函数</li>
</ul>

<blockquote>
  <p>前言 默认你是对数组有一定的认识。</p>
</blockquote>

<h4>1. Slice数据结构</h4>

<p>首先，直接从源码<code>$YOUR_GO_DIR/src/runtime/slice.go</code>（其中<code>$YOUR_GO_DIR</code>指你自己go源代码的根目录）中找到定义的<code>slice</code>结构，如下：</p>

<pre><code>type slice struct {
    array unsafe.Pointer // 任意类型指针(类似C语言中的 void* )， 指向真实存储slice数据的数组
    len   int // length, 长度
    cap   int // capacity, 容量
}
</code></pre>

<p>从结构很好看出，通过make()函数（比如：make([]int, 10, 20)）创建出来的slice，其实就是由两部分组成：<code>slice的"描述"(上面的结构体)</code> + <code>存储数据的数组(指针指向的数组)</code>。</p>

<blockquote>
  <p>提示：后文将使用SliceHeader代替上面的结构体，SliceHeader是<a href="https://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a>在<a href="https://blog.golang.org/slices">Golang/slices</a>这篇博文中的暂用来指代的名词，这里我也借用一下。为了方便理解，把slice拆成 SliceHeader + 存储数据的数组 两部分。</p>
</blockquote>

<h4>2. 使用Slice须知</h4>

<h4>2.1 值传递下的Slice</h4>

<p>我们知道Go的参数是值传递，那么这里有个问题需要考虑： <strong>当把一个slice变量通过参数传递给某函数时，传的是SliceHeader、还是整个SliceHeader+数据（存储数据的数组）都被复制过去？</strong></p>

<p>比如，这样的代码：  </p>

<pre><code>s := make([]string, 10)  
saveSlice(s)
</code></pre>

<p>当我们在项目中某个slice有10万元素，如果传参数直接复制<code>SliceHeader + 数据</code>，那么这是一定不能接受的。</p>

<p>Rob Pike有这样一句话定义Slice: <code>slice不是数组，它是对数组进行了描述(A slice is not an array. A slice describes a piece of an array)</code>。 实际上，在上面的代码片段中saveSlice(s)接收到的是变量<code>s</code>的一个副本（就是一个值跟<code>s</code>一样，但是是全新的变量），这个副本跟变量<code>s</code>一样，有一个指向同个数组的指针、len和cap相同值。</p>

<p>为什么？因为Go是值传递，简单试验就知道。</p>

<p><strong>实验 1</strong>  </p>

<p>假设：如果slice变量参数传递，是复制了<code>数据</code>，那么在函数中操作"被复制过来的"数据，<strong>不会</strong>对原数据造成影响。</p>

<pre><code>// 代码片段
data := make([]int, 10)
fmt.Println("处理前数据: ", data)
changeIndex0(data)
fmt.Println("处理后数据: ", data)
</code></pre>

<p>函数 changeIndex0(data []int)</p>

<pre><code>// 替换第一个元素的值
func changeIndex0(data []int)  {
    data[0] = 99
}
</code></pre>

<p>实验结果</p>

<pre><code>处理前数据:  [0 0 0 0 0 0 0 0 0 0]
处理后数据:  [99 0 0 0 0 0 0 0 0 0]
</code></pre>

<p>显然，从结果中看得出，原始数据被修改了，所以可以得出结论是：传递slice变量时，并不是复制真正存储数据的数组进行传递。</p>

<p><strong>实验 2</strong></p>

<p>如何证明传的是SliceHeader，并且函数所接受到的变量是一个副本？</p>

<pre><code>// 代码片段
data := make([]int, 10)
fmt.Println("处理前数据: ", data, len(data), cap(data))
subSlice(data)
fmt.Println("处理后数据: ", data, len(data), cap(data))
</code></pre>

<p>函数 subSlic(data []int)</p>

<pre><code>// 截取slice
func subSlice(data []int)  {
    data[0] = 99
    data = data[0:8]
    fmt.Println("函数中数据: ", data, len(data), cap(data))
}
</code></pre>

<p>实验结果</p>

<pre><code>处理前数据:  [0 0 0 0 0 0 0 0 0 0] 10 10
函数中数据:  [99 0 0 0 0 0 0 0] 8 10
处理后数据:  [99 0 0 0 0 0 0 0 0 0] 10 10
</code></pre>

<p>结果中看到函数中和处理后的slice的长度（len）不一样，显然不是同一个SliceHeader。其实也有个简单的办法，直接取两变量的地址，一看就知道。（这个实验根本就可以不用，因为Go参数传递本身就是值传递，自然会复制，不像Java的引用传递）。</p>

<p>所以，在实际项目中，直接传递slice变量与传递slice变量的指针，对内存的消耗区别并不是很大。一个SliceHeader的大小是24字节，而指针大小8字节。</p>

<blockquote>
  <p>备注： SliceHeader 24字节计算方式：8字节(指针) + 8字节(整型int, len) + 8字节(整型int, cap)，这是以我自己电脑为例， 我电脑是64位，指针大小8字节；整型int大小也跟编译器有关，但Golang中最少是32bit，我在本机使用unsafe.SizeOf()实测是8字节。</p>
</blockquote>

<h4>2.2 Slice截取和扩充</h4>

<h4>3. Slice操作常用函数</h4>

<p>参考：</p>

<ol>
<li><a href="https://blog.golang.org/slices">Golang/slices</a></li>
</ol>
</div>

        <br/>
        <br/>

        <!--Disqus-->
        <div id="disqus_thread"></div>
        <script>
            /**
            * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
            * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
            */
            /*
            var disqus_config = function () {
            this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
            };
            */
            (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');

            s.src = '//hikoim.disqus.com/embed.js';

            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
        <footer class="site-footer">
    <span class="site-footer-credits">博客代码# <a href="https://github.com/HikoQiu/hikoqiu.github.com">hikoqiu.github.com</a>.</span>
</footer>

    </section>

  </body>
</html>
